{"version":3,"file":"index.js","mappings":"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","sources":["webpack://isar/./node_modules/fast-deep-equal/index.js","webpack://isar/webpack/bootstrap","webpack://isar/webpack/runtime/compat get default export","webpack://isar/webpack/runtime/define property getters","webpack://isar/webpack/runtime/hasOwnProperty shorthand","webpack://isar/./src/bulk-delete.ts","webpack://isar/./src/helper.ts","webpack://isar/./src/schema.ts","webpack://isar/./src/link.ts","webpack://isar/./src/watcher.ts","webpack://isar/./src/collection.ts","webpack://isar/./src/txn.ts","webpack://isar/./node_modules/broadcast-channel/dist/esbrowser/util.js","webpack://isar/./node_modules/broadcast-channel/dist/esbrowser/methods/native.js","webpack://isar/./node_modules/oblivious-set/dist/es/index.js","webpack://isar/./node_modules/broadcast-channel/dist/esbrowser/options.js","webpack://isar/./node_modules/broadcast-channel/dist/esbrowser/methods/indexed-db.js","webpack://isar/./node_modules/broadcast-channel/dist/esbrowser/methods/localstorage.js","webpack://isar/./node_modules/broadcast-channel/dist/esbrowser/methods/simulate.js","webpack://isar/./node_modules/broadcast-channel/dist/esbrowser/method-chooser.js","webpack://isar/./node_modules/broadcast-channel/dist/esbrowser/broadcast-channel.js","webpack://isar/./src/instance.ts","webpack://isar/./src/open.ts","webpack://isar/./src/cursor.ts","webpack://isar/./src/index.ts","webpack://isar/./src/query.ts"],"sourcesContent":["'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { IsarTxn } from './txn'\n\nexport function bulkDelete(\n  txn: IsarTxn,\n  storeName: string,\n  keys: (IDBValidKey | IDBKeyRange)[],\n): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const len = keys.length\n    const lastItem = len - 1\n    if (len === 0) return resolve()\n    const store = txn.txn.objectStore(storeName)\n    for (let i = 0; i < keys.length; i++) {\n      const req = store.delete(keys[i])\n      req.onerror = () => {\n        txn.abort()\n        reject(req.error)\n      }\n      if (i === lastItem) {\n        req.onsuccess = () => {\n          resolve()\n        }\n      }\n    }\n  })\n}\n\nexport function bulkDeleteByIndex(\n  txn: IsarTxn,\n  storeName: string,\n  indexName: string,\n  keys: IDBValidKey[],\n): Promise<IDBValidKey[]> {\n  if (keys.length === 0) return Promise.resolve([])\n  return new Promise((resolve, reject) => {\n    const store = txn.txn.objectStore(storeName)\n    const index = store.index(indexName)\n\n    const primaryKeys: IDBValidKey[] = []\n    for (var i = 0; i < keys.length; i++) {\n      const indexReq = index.getAllKeys(keys[i])\n      const isLast = i === keys.length - 1\n      indexReq.onsuccess = () => {\n        primaryKeys.push(...indexReq.result)\n        if (isLast) {\n          bulkDelete(txn, storeName, primaryKeys).then(\n            () => resolve(primaryKeys),\n            reject,\n          )\n        }\n      }\n      indexReq.onerror = () => {\n        txn.abort()\n        reject(indexReq.error)\n      }\n    }\n  })\n}\n","export function val2Idb(value: any): any {\n  if (value == null || value != value) {\n    return -Infinity\n  } else if (value === true) {\n    return 1\n  } else if (value === false) {\n    return 0\n  } else {\n    return value\n  }\n}\n\nexport function obj2Idb(object: any, idName: string): any {\n  const result: any = Object.create(null, {})\n  for (let key of Object.keys(object)) {\n    const val = object[key]\n    if (Array.isArray(val)) {\n      result[key] = val.map(val2Idb)\n    } else if (key !== idName || (val != null && val !== -Infinity)) {\n      result[key] = val2Idb(val)\n    }\n  }\n  return result\n}\n\nexport function idb2Obj(object: any, boolValues: string[]): any {\n  const result: any = {}\n  for (let key of Object.keys(object)) {\n    const val = object[key]\n    if (val === -Infinity) {\n      result[key] = null\n    } else if (boolValues.indexOf(key) !== -1) {\n      if (Array.isArray(val)) {\n        result[key] = val.map(v => (v === -Infinity ? null : v > 0))\n      } else {\n        result[key] = val === 1\n      }\n    } else if (Array.isArray(val)) {\n      result[key] = val.map(v => (v === -Infinity ? null : v))\n    } else {\n      result[key] = val\n    }\n  }\n  return result\n}\n","import equal from 'fast-deep-equal'\n\nexport type Schema = {\n  name: string\n  idName: string\n  properties: Array<PropertySchema>\n  indexes: Array<IndexSchema>\n  links: Array<LinkSchema>\n}\n\ntype PropertySchema = {\n  name: string\n  type: IsarType\n}\n\ntype IndexSchema = {\n  name: string\n  unique: boolean\n  properties: Array<IndexPropertySchema>\n}\n\ntype IndexPropertySchema = {\n  name: string\n  type: IndexType\n  caseSensitive: boolean\n}\n\nexport namespace IndexSchema {\n  export function isIndexMultiEntry(\n    schema: Schema,\n    indexSchema: IndexSchema,\n  ): boolean {\n    return indexSchema.properties.some(ip => {\n      const property = schema.properties.find(p => p.name === ip.name)!\n      return ip.type === IndexType.Value && IsarType.isList(property.type)\n    })\n  }\n\n  export function getKeyPath(indexSchema: IndexSchema): string | string[] {\n    return indexSchema.properties.length === 1\n      ? indexSchema.properties[0].name\n      : indexSchema.properties.map(p => p.name)\n  }\n\n  export function matchesIndex(\n    schema: Schema,\n    indexSchema: IndexSchema,\n    index: IDBIndex,\n  ): boolean {\n    return (\n      index.name === indexSchema.name &&\n      index.multiEntry === isIndexMultiEntry(schema, indexSchema) &&\n      index.unique === indexSchema.unique &&\n      equal(index.keyPath, getKeyPath(indexSchema))\n    )\n  }\n}\n\ntype LinkSchema = {\n  name: string\n  target: string\n}\n\nexport namespace LinkSchema {\n  export function getStoreName(\n    sourceName: string,\n    targetName: string,\n    linkName: string,\n  ): string {\n    return `_${sourceName}_${targetName}_${linkName}`\n  }\n}\n\nexport enum IsarType {\n  Bool = 'Bool',\n  Int = 'Int',\n  Float = 'Float',\n  Long = 'Long',\n  Double = 'Double',\n  String = 'String',\n  ByteList = 'ByteList',\n  BoolList = 'BoolList',\n  IntList = 'IntList',\n  FloatList = 'FloatList',\n  LongList = 'LongList',\n  DoubleList = 'DoubleList',\n  StringList = 'StringList',\n}\n\nexport namespace IsarType {\n  export function isList(type: IsarType): boolean {\n    return [\n      IsarType.ByteList,\n      IsarType.BoolList,\n      IsarType.IntList,\n      IsarType.FloatList,\n      IsarType.LongList,\n      IsarType.DoubleList,\n      IsarType.StringList,\n    ].includes(type)\n  }\n}\n\nenum IndexType {\n  Value = 'Value',\n  Hash = 'Hash',\n  HashElements = 'HashElements',\n}\n","import { bulkDelete } from './bulk-delete'\nimport { IsarInstance } from './instance'\nimport { LinkSchema } from './schema'\nimport { IsarTxn } from './txn'\n\nexport class IsarLink {\n  static readonly BacklinkIndex = 'backlink'\n\n  readonly isar: IsarInstance\n  readonly name: string\n  readonly sourceName: string\n  readonly targetName: string\n  readonly storeName: string\n\n  constructor(\n    isar: IsarInstance,\n    name: string,\n    sourceName: string,\n    targetName: string,\n  ) {\n    this.isar = isar\n    this.name = name\n    this.sourceName = sourceName\n    this.targetName = targetName\n    this.storeName = LinkSchema.getStoreName(sourceName, targetName, name)\n  }\n\n  private getLinkEntry(source: number, target: number, backlink: boolean): any {\n    if (backlink) {\n      ;[source, target] = [target, source]\n    }\n    return {\n      a: source,\n      b: target,\n    }\n  }\n\n  static getLinkKeyRange(id: number): IDBKeyRange {\n    return IDBKeyRange.bound([id, -Infinity], [id, Infinity])\n  }\n\n  update(\n    txn: IsarTxn,\n    backlink: boolean,\n    id: number,\n    addedTargets: number[],\n    deletedTargets: number[],\n  ): Promise<void> {\n    if (addedTargets.length === 0 && deletedTargets.length === 0) {\n      return Promise.resolve()\n    }\n\n    return new Promise((resolve, reject) => {\n      const store = txn.txn.objectStore(this.storeName)\n\n      const deletedEmpty = deletedTargets.length === 0\n      for (let i = 0; i < addedTargets.length; i++) {\n        let target = addedTargets[i]\n        const req = store.add(this.getLinkEntry(id, target, backlink))\n        if (deletedEmpty && i === addedTargets.length - 1) {\n          req.onsuccess = () => {\n            resolve()\n          }\n        }\n        req.onerror = () => {\n          txn.abort()\n          reject(req.error)\n        }\n      }\n\n      for (let i = 0; i < deletedTargets.length; i++) {\n        let target = deletedTargets[i]\n        const key = backlink ? [target, id] : [id, target]\n        const req = store.delete(key)\n        if (i === deletedTargets.length - 1) {\n          req.onsuccess = () => {\n            resolve()\n          }\n        }\n        req.onerror = () => {\n          txn.abort()\n          reject(req.error)\n        }\n      }\n    })\n  }\n\n  clear(txn: IsarTxn, id: number, backlink: boolean): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const store = txn.txn.objectStore(this.storeName)\n      if (backlink) {\n        const keysRes = store.index(IsarLink.BacklinkIndex).getAllKeys(id)\n        keysRes.onsuccess = () => {\n          const keys = keysRes.result\n          if (keys.length > 0) {\n            const ids = keys.map(key => (key as number[])[1])\n            bulkDelete(txn, this.storeName, ids).then(resolve, reject)\n          } else {\n            resolve()\n          }\n        }\n        keysRes.onerror = () => {\n          txn.abort()\n          reject(keysRes.error)\n        }\n      } else {\n        const deleteReq = store.delete(IsarLink.getLinkKeyRange(id))\n        deleteReq.onsuccess = () => {\n          resolve()\n        }\n        deleteReq.onerror = () => {\n          txn.abort()\n          reject(deleteReq.error)\n        }\n      }\n    })\n  }\n}\n","import { IsarQuery } from './query'\nimport { IsarTxn } from './txn'\n\ntype ChangeCallback = () => void\n\ntype ObjectChangeCallback<OBJ> = (object?: OBJ) => void\n\ntype QueryChangeCallback<OBJ> = (results: OBJ[]) => void\n\ntype StopWatching = () => void\n\ntype QueryWatcher<OBJ> = {\n  callback: ChangeCallback | QueryChangeCallback<OBJ>\n  query: IsarQuery<OBJ>\n  lazy: boolean\n}\n\nexport type ChangeSet<OBJ> = {\n  cleared: boolean\n  addedObjects: Map<number, OBJ>\n  deletedObjectIds: Set<number>\n}\n\nexport class IsarChangeSet<OBJ> implements IsarChangeSet<OBJ> {\n  cleared: boolean = false\n  addedObjects: Map<number, OBJ> = new Map()\n  deletedObjectIds: Set<number> = new Set()\n\n  registerChange(id: number, idbObject?: OBJ) {\n    if (idbObject) {\n      this.addedObjects.set(id, idbObject)\n      this.deletedObjectIds.delete(id)\n    } else {\n      this.deletedObjectIds.add(id)\n      this.addedObjects.delete(id)\n    }\n  }\n\n  registerCleared() {\n    this.addedObjects.clear()\n    this.deletedObjectIds.clear()\n    this.cleared = true\n  }\n}\n\nexport class IsarWatchable<OBJ> {\n  readonly collectionWatchers = new Set<ChangeCallback>()\n  readonly objectWatchers: Map<number, Set<ObjectChangeCallback<OBJ>>> =\n    new Map()\n  readonly queryWatchers = new Set<QueryWatcher<OBJ>>()\n\n  watchLazy(callback: ChangeCallback): StopWatching {\n    this.collectionWatchers.add(callback)\n    return () => this.collectionWatchers.delete(callback)\n  }\n\n  watchObject(id: number, callback: ObjectChangeCallback<OBJ>): StopWatching {\n    let ow = this.objectWatchers.get(id)\n    if (ow == null) {\n      ow = new Set()\n      this.objectWatchers.set(id, ow)\n    }\n    ow.add(callback)\n    return () => {\n      if (ow!.size <= 1) {\n        this.objectWatchers.delete(id)\n      } else {\n        ow!.delete(callback)\n      }\n    }\n  }\n\n  private watchQueryInternal(\n    query: IsarQuery<OBJ>,\n    lazy: boolean,\n    callback: ChangeCallback | QueryChangeCallback<OBJ>,\n  ): StopWatching {\n    const watcher = { callback, query, lazy }\n    this.queryWatchers.add(watcher)\n    return () => this.queryWatchers.delete(watcher)\n  }\n\n  watchQuery(\n    query: IsarQuery<OBJ>,\n    callback: QueryChangeCallback<OBJ>,\n  ): StopWatching {\n    return this.watchQueryInternal(query, false, callback)\n  }\n\n  watchQueryLazy(\n    query: IsarQuery<OBJ>,\n    callback: ChangeCallback,\n  ): StopWatching {\n    return this.watchQueryInternal(query, true, callback)\n  }\n\n  notify(changes: ChangeSet<OBJ>, getTxn: () => IsarTxn) {\n    if (\n      !changes.cleared &&\n      changes.addedObjects.size === 0 &&\n      changes.deletedObjectIds.size === 0\n    ) {\n      return\n    }\n\n    function notifyQuery(watcher: QueryWatcher<OBJ>) {\n      if (watcher.lazy) {\n        ;(watcher.callback as ChangeCallback)()\n      } else {\n        const txn = getTxn()\n        watcher.query.findAll(txn).then(watcher.callback)\n      }\n    }\n\n    for (const watcher of this.collectionWatchers) {\n      watcher()\n    }\n\n    let queryWatchers: Set<QueryWatcher<OBJ>> | undefined\n    if (changes.cleared || changes.deletedObjectIds.size > 0) {\n      for (const watcher of this.queryWatchers) {\n        notifyQuery(watcher)\n      }\n    } else {\n      queryWatchers = new Set(this.queryWatchers)\n    }\n\n    if (changes.cleared) {\n      for (const [id, callbacks] of this.objectWatchers) {\n        for (let callback of callbacks) {\n          callback(changes.addedObjects.get(id))\n        }\n      }\n    } else {\n      for (const id of changes.deletedObjectIds) {\n        const callbacks = this.objectWatchers.get(id)\n        if (callbacks != null) {\n          for (let callback of callbacks) {\n            callback(undefined)\n          }\n        }\n      }\n\n      for (const [id, added] of changes.addedObjects) {\n        const ow = this.objectWatchers.get(id)\n        if (ow != null) {\n          for (let callback of ow) {\n            callback(added)\n          }\n        }\n\n        if (queryWatchers != null) {\n          for (const watcher of queryWatchers) {\n            if (watcher.query.whereClauseAndFilterMatch(id, added)) {\n              notifyQuery(watcher)\n              queryWatchers.delete(watcher)\n            }\n          }\n        }\n      }\n    }\n  }\n}\n","import { bulkDelete, bulkDeleteByIndex } from './bulk-delete'\nimport { idb2Obj, obj2Idb, val2Idb } from './helper'\nimport { IsarInstance } from './instance'\nimport { IsarLink } from './link'\nimport { IndexSchema, IsarType, Schema } from './schema'\nimport { IsarTxn } from './txn'\nimport { IsarWatchable } from './watcher'\n\ninterface UniqueIndex {\n  readonly name: string\n  readonly accessors: string[]\n}\n\nexport type IndexKey = string | number | boolean | IndexKey[]\n\nexport class IsarCollection<OBJ> extends IsarWatchable<OBJ> {\n  readonly isar: IsarInstance\n  readonly name: string\n  readonly idName: string\n  private readonly boolValues: string[]\n  private readonly uniqueIndexes: ReadonlyArray<UniqueIndex>\n  private readonly links: ReadonlyArray<IsarLink>\n  // only backlinks that don't target this collection\n  private readonly backlinkStoreNames: ReadonlyArray<string>\n  private readonly multiEntryIndexes: string[]\n  private readonly indexKeyPaths = new Map<string, string[]>()\n\n  constructor(\n    isar: IsarInstance,\n    schema: Schema,\n    backlinkStoreNames: string[],\n  ) {\n    super()\n    this.isar = isar\n    this.name = schema.name\n    this.idName = schema.idName\n    this.boolValues = schema.properties\n      .filter(p => p.type == IsarType.Bool || p.type == IsarType.BoolList)\n      .map(p => p.name)\n    this.uniqueIndexes = schema.indexes\n      .filter(i => i.unique)\n      .map(i => ({\n        name: i.name,\n        accessors: i.properties.map(p => p.name),\n      }))\n    this.links = schema.links.map(\n      l => new IsarLink(isar, l.name, schema.name, l.target),\n    )\n    this.backlinkStoreNames = backlinkStoreNames\n    this.multiEntryIndexes = schema.indexes\n      .filter(i => IndexSchema.isIndexMultiEntry(schema, i))\n      .map(i => i.name)\n    this.indexKeyPaths = new Map(\n      schema.indexes.map(i => [i.name, i.properties.map(p => p.name)]),\n    )\n  }\n\n  getLink(name: string): IsarLink | undefined {\n    return this.links.find(l => l.name === name)\n  }\n\n  toObject(obj: any): OBJ {\n    return idb2Obj(obj, this.boolValues)\n  }\n\n  getId(obj: OBJ): number {\n    return (obj as any)[this.idName]\n  }\n\n  getIndexKeyPath(indexName: string): string[] {\n    return this.indexKeyPaths.get(indexName)!\n  }\n\n  isMultiEntryIndex(indexName: string): boolean {\n    return this.multiEntryIndexes.includes(indexName)\n  }\n\n  private prepareKey(key: IndexKey): IDBValidKey {\n    if (Array.isArray(key)) {\n      if (key.length == 1) {\n        return val2Idb(key[0])\n      } else {\n        return key.map(val2Idb)\n      }\n    } else {\n      return val2Idb(key)\n    }\n  }\n\n  private getInternal(\n    source: IDBObjectStore | IDBIndex,\n    key: IDBValidKey,\n  ): Promise<OBJ | undefined> {\n    return new Promise((resolve, reject) => {\n      let req = source.get(key)\n      req.onsuccess = () => {\n        const object = req.result ? this.toObject(req.result) : undefined\n        resolve(object)\n      }\n      req.onerror = () => {\n        reject(req.error)\n      }\n    })\n  }\n\n  get(txn: IsarTxn, id: number): Promise<OBJ | undefined> {\n    let store = txn.txn.objectStore(this.name)\n    return this.getInternal(store, id)\n  }\n\n  getByIndex(\n    txn: IsarTxn,\n    indexName: string,\n    key: IndexKey,\n  ): Promise<OBJ | undefined> {\n    let index = txn.txn.objectStore(this.name).index(indexName)\n    return this.getInternal(index, this.prepareKey(key))\n  }\n\n  getAllInternal(\n    txn: IsarTxn,\n    keys: IDBValidKey[],\n    includeUndefined: boolean,\n    indexName?: string,\n  ): Promise<(OBJ | undefined)[]> {\n    return new Promise((resolve, reject) => {\n      const store = txn.txn.objectStore(this.name)\n      const source = indexName ? store.index(indexName) : store\n      const results: (OBJ | undefined)[] = []\n      for (let i = 0; i < keys.length; i++) {\n        let req = source.get(keys[i])\n        req.onsuccess = () => {\n          const result = req.result\n          if (result) {\n            results.push(this.toObject(result))\n          } else if (includeUndefined) {\n            results.push(undefined)\n          }\n          if (results.length == keys.length) {\n            resolve(results)\n          }\n        }\n        req.onerror = () => {\n          reject(req.error)\n        }\n      }\n    })\n  }\n\n  getAll(txn: IsarTxn, ids: number[]): Promise<(OBJ | undefined)[]> {\n    return this.getAllInternal(txn, ids, true)\n  }\n\n  getAllByIndex(\n    txn: IsarTxn,\n    indexName: string,\n    keys: IndexKey[],\n  ): Promise<(OBJ | undefined)[]> {\n    const idbKeys = keys.map(this.prepareKey)\n    return this.getAllInternal(txn, idbKeys, true, indexName)\n  }\n\n  put(\n    txn: IsarTxn,\n    object: OBJ,\n    replaceOnConflict: boolean = false,\n  ): Promise<number> {\n    let store = txn.txn.objectStore(this.name)\n    /*if (replaceOnConflict) {\n            for (let index of this.uniqueIndexes) {\n                let indexStore = store.index(index.name)\n                let req = indexStore.get(obj[index.accessor])\n                req.onsuccess = () => {\n                    if (req.result) {\n                        txn.txn.abort()\n                    }\n                }\n            }\n        }*/\n\n    return new Promise((resolve, reject) => {\n      const req = store.put(obj2Idb(object, this.idName))\n      req.onsuccess = () => {\n        const id = req.result as number\n        txn.getChangeSet(this.name).registerChange(id, object)\n        resolve(id)\n      }\n      req.onerror = () => {\n        txn.abort()\n        reject(req.error)\n      }\n    })\n  }\n\n  putAll(\n    txn: IsarTxn,\n    objects: OBJ[],\n    replaceOnConflict: boolean = false,\n  ): Promise<number[]> {\n    let store = txn.txn.objectStore(this.name)\n    if (replaceOnConflict) {\n      throw 'Replace on conflict not implemented'\n    }\n    return new Promise((resolve, reject) => {\n      const ids: (number | undefined)[] = []\n      const changeSet = txn.getChangeSet(this.name)\n      for (let i = 0; i < objects.length; i++) {\n        let object = obj2Idb(objects[i], this.idName)\n        const req = store.put(object)\n        const id = this.getId(object)\n        ids.push(id)\n        if (!id) {\n          req.onsuccess = () => {\n            const id = req.result as number\n            ids[i] = id\n            changeSet.registerChange(id, object)\n            if (i === objects.length - 1) {\n              resolve(ids as number[])\n            }\n          }\n        } else {\n          changeSet.registerChange(id, object)\n          if (i === objects.length - 1) {\n            req.onsuccess = () => {\n              resolve(ids as number[])\n            }\n          }\n        }\n        req.onerror = () => {\n          txn.abort()\n          reject(req.error)\n        }\n      }\n    })\n  }\n\n  private deleteLinks(txn: IsarTxn, keys: IDBValidKey[]): Promise<void> {\n    if (this.links.length === 0 && this.backlinkStoreNames.length === 0) {\n      return Promise.resolve()\n    }\n    const linkPromises = this.links.map(l => {\n      return bulkDelete(txn, l.storeName, keys.map(IsarLink.getLinkKeyRange))\n    })\n    const backlinkPromises = this.backlinkStoreNames.map(storeName => {\n      return bulkDeleteByIndex(txn, storeName, IsarLink.BacklinkIndex, keys)\n    })\n    return Promise.all([...linkPromises, ...backlinkPromises]).then(() => {})\n  }\n\n  delete(txn: IsarTxn, id: number): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const store = txn.txn.objectStore(this.name)\n      const req = store.delete(id)\n      req.onsuccess = () => {\n        txn.getChangeSet(this.name).registerChange(id)\n        this.deleteLinks(txn, [id]).then(resolve, reject)\n      }\n      req.onerror = () => {\n        reject(req.error)\n      }\n    })\n  }\n\n  deleteByIndex(\n    txn: IsarTxn,\n    indexName: string,\n    key: IndexKey,\n  ): Promise<boolean> {\n    return new Promise((resolve, reject) => {\n      const store = txn.txn.objectStore(this.name)\n      const index = store.index(indexName)\n      const indexReq = index.getKey(this.prepareKey(key))\n      indexReq.onsuccess = () => {\n        const id = indexReq.result as number | undefined\n        if (id) {\n          const req = store.delete(id)\n          req.onsuccess = () => {\n            txn.getChangeSet(this.name).registerChange(id)\n            this.deleteLinks(txn, [id]).then(() => resolve(true), reject)\n          }\n          req.onerror = () => {\n            reject(req.error)\n          }\n        } else {\n          resolve(false)\n        }\n      }\n      indexReq.onerror = () => {\n        reject(indexReq.error)\n      }\n    })\n  }\n\n  deleteAll(txn: IsarTxn, ids: number[]): Promise<void> {\n    return bulkDelete(txn, this.name, ids).then(() => {\n      const changeSet = txn.getChangeSet(this.name)\n      for (let id of ids) {\n        changeSet.registerChange(id)\n      }\n      return this.deleteLinks(txn, ids)\n    })\n  }\n\n  deleteAllByIndex(\n    txn: IsarTxn,\n    indexName: string,\n    keys: IndexKey[],\n  ): Promise<number> {\n    const idbKeys = keys.map(this.prepareKey)\n    return bulkDeleteByIndex(txn, this.name, indexName, idbKeys).then(ids => {\n      const changeSet = txn.getChangeSet(this.name)\n      for (let id of ids as number[]) {\n        changeSet.registerChange(id)\n      }\n      return this.deleteLinks(txn, ids).then(() => ids.length)\n    })\n  }\n\n  clear(txn: IsarTxn): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const storeNames = [\n        this.name,\n        ...this.backlinkStoreNames,\n        ...this.links.map(l => l.storeName),\n      ]\n      for (let i = 0; i < storeNames.length; i++) {\n        const store = txn.txn.objectStore(this.name)\n        const req = store.clear()\n        req.onerror = () => {\n          reject(req.error)\n        }\n        if (i === storeNames.length - 1) {\n          req.onsuccess = () => {\n            txn.getChangeSet(this.name).registerCleared()\n            resolve()\n          }\n        }\n      }\n    })\n  }\n}\n","import { IsarInstance } from './instance'\nimport { IsarChangeSet } from './watcher'\n\nexport class IsarTxn {\n  readonly isar: IsarInstance\n  readonly txn: IDBTransaction\n  active: boolean\n  readonly write: boolean\n  private readonly changes: Map<string, IsarChangeSet<any>> | undefined\n\n  constructor(isar: IsarInstance, txn: IDBTransaction, write: boolean) {\n    this.isar = isar\n    this.txn = txn\n    this.active = true\n    this.write = write\n\n    if (write) {\n      this.changes = new Map()\n    }\n  }\n\n  getChangeSet<OBJ>(collectionName: string): IsarChangeSet<OBJ> {\n    let changeSet = this.changes!.get(collectionName)\n    if (changeSet == null) {\n      changeSet = new IsarChangeSet()\n      this.changes!.set(collectionName, changeSet)\n    }\n    return changeSet\n  }\n\n  commit(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.active = false\n\n      this.txn.oncomplete = () => {\n        if (this.changes) {\n          this.isar.notifyWatchers(this.changes)\n        }\n        resolve()\n      }\n      this.txn.onerror = () => {\n        reject(this.txn.error)\n      }\n      this.txn.commit()\n    })\n  }\n\n  abort() {\n    if (this.active) {\n      this.active = false\n      this.txn.abort()\n    }\n  }\n}\n","/**\n * returns true if the given object is a promise\n */\nexport function isPromise(obj) {\n  if (obj && typeof obj.then === 'function') {\n    return true;\n  } else {\n    return false;\n  }\n}\nexport var PROMISE_RESOLVED_FALSE = Promise.resolve(false);\nexport var PROMISE_RESOLVED_TRUE = Promise.resolve(true);\nexport var PROMISE_RESOLVED_VOID = Promise.resolve();\nexport function sleep(time, resolveWith) {\n  if (!time) time = 0;\n  return new Promise(function (res) {\n    return setTimeout(function () {\n      return res(resolveWith);\n    }, time);\n  });\n}\nexport function randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n/**\n * https://stackoverflow.com/a/8084248\n */\n\nexport function randomToken() {\n  return Math.random().toString(36).substring(2);\n}\nvar lastMs = 0;\nvar additional = 0;\n/**\n * returns the current time in micro-seconds,\n * WARNING: This is a pseudo-function\n * Performance.now is not reliable in webworkers, so we just make sure to never return the same time.\n * This is enough in browsers, and this function will not be used in nodejs.\n * The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.\n */\n\nexport function microSeconds() {\n  var ms = new Date().getTime();\n\n  if (ms === lastMs) {\n    additional++;\n    return ms * 1000 + additional;\n  } else {\n    lastMs = ms;\n    additional = 0;\n    return ms * 1000;\n  }\n}\n/**\n * copied from the 'detect-node' npm module\n * We cannot use the module directly because it causes problems with rollup\n * @link https://github.com/iliakan/detect-node/blob/master/index.js\n */\n\nexport var isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';","import { microSeconds as micro, isNode, PROMISE_RESOLVED_VOID } from '../util';\nexport var microSeconds = micro;\nexport var type = 'native';\nexport function create(channelName) {\n  var state = {\n    messagesCallback: null,\n    bc: new BroadcastChannel(channelName),\n    subFns: [] // subscriberFunctions\n\n  };\n\n  state.bc.onmessage = function (msg) {\n    if (state.messagesCallback) {\n      state.messagesCallback(msg.data);\n    }\n  };\n\n  return state;\n}\nexport function close(channelState) {\n  channelState.bc.close();\n  channelState.subFns = [];\n}\nexport function postMessage(channelState, messageJson) {\n  try {\n    channelState.bc.postMessage(messageJson, false);\n    return PROMISE_RESOLVED_VOID;\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\nexport function onMessage(channelState, fn) {\n  channelState.messagesCallback = fn;\n}\nexport function canBeUsed() {\n  /**\n   * in the electron-renderer, isNode will be true even if we are in browser-context\n   * so we also check if window is undefined\n   */\n  if (isNode && typeof window === 'undefined') return false;\n\n  if (typeof BroadcastChannel === 'function') {\n    if (BroadcastChannel._pubkey) {\n      throw new Error('BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill');\n    }\n\n    return true;\n  } else return false;\n}\nexport function averageResponseTime() {\n  return 150;\n}\nexport default {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};","/**\n * this is a set which automatically forgets\n * a given entry when a new entry is set and the ttl\n * of the old one is over\n */\nvar ObliviousSet = /** @class */ (function () {\n    function ObliviousSet(ttl) {\n        this.ttl = ttl;\n        this.set = new Set();\n        this.timeMap = new Map();\n    }\n    ObliviousSet.prototype.has = function (value) {\n        return this.set.has(value);\n    };\n    ObliviousSet.prototype.add = function (value) {\n        var _this = this;\n        this.timeMap.set(value, now());\n        this.set.add(value);\n        /**\n         * When a new value is added,\n         * start the cleanup at the next tick\n         * to not block the cpu for more important stuff\n         * that might happen.\n         */\n        setTimeout(function () {\n            removeTooOldValues(_this);\n        }, 0);\n    };\n    ObliviousSet.prototype.clear = function () {\n        this.set.clear();\n        this.timeMap.clear();\n    };\n    return ObliviousSet;\n}());\nexport { ObliviousSet };\n/**\n * Removes all entries from the set\n * where the TTL has expired\n */\nexport function removeTooOldValues(obliviousSet) {\n    var olderThen = now() - obliviousSet.ttl;\n    var iterator = obliviousSet.set[Symbol.iterator]();\n    /**\n     * Because we can assume the new values are added at the bottom,\n     * we start from the top and stop as soon as we reach a non-too-old value.\n     */\n    while (true) {\n        var value = iterator.next().value;\n        if (!value) {\n            return; // no more elements\n        }\n        var time = obliviousSet.timeMap.get(value);\n        if (time < olderThen) {\n            obliviousSet.timeMap.delete(value);\n            obliviousSet.set.delete(value);\n        }\n        else {\n            // We reached a value that is not old enough\n            return;\n        }\n    }\n}\nexport function now() {\n    return new Date().getTime();\n}\n//# sourceMappingURL=index.js.map","export function fillOptionsWithDefaults() {\n  var originalOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var options = JSON.parse(JSON.stringify(originalOptions)); // main\n\n  if (typeof options.webWorkerSupport === 'undefined') options.webWorkerSupport = true; // indexed-db\n\n  if (!options.idb) options.idb = {}; //  after this time the messages get deleted\n\n  if (!options.idb.ttl) options.idb.ttl = 1000 * 45;\n  if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150; //  handles abrupt db onclose events.\n\n  if (originalOptions.idb && typeof originalOptions.idb.onclose === 'function') options.idb.onclose = originalOptions.idb.onclose; // localstorage\n\n  if (!options.localstorage) options.localstorage = {};\n  if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1000 * 60; // custom methods\n\n  if (originalOptions.methods) options.methods = originalOptions.methods; // node\n\n  if (!options.node) options.node = {};\n  if (!options.node.ttl) options.node.ttl = 1000 * 60 * 2; // 2 minutes;\n\n  /**\n   * On linux use 'ulimit -Hn' to get the limit of open files.\n   * On ubuntu this was 4096 for me, so we use half of that as maxParallelWrites default.\n   */\n\n  if (!options.node.maxParallelWrites) options.node.maxParallelWrites = 2048;\n  if (typeof options.node.useFastPath === 'undefined') options.node.useFastPath = true;\n  return options;\n}","/**\n * this method uses indexeddb to store the messages\n * There is currently no observerAPI for idb\n * @link https://github.com/w3c/IndexedDB/issues/51\n * \n * When working on this, ensure to use these performance optimizations:\n * @link https://rxdb.info/slow-indexeddb.html\n */\nimport { sleep, randomInt, randomToken, microSeconds as micro, isNode, PROMISE_RESOLVED_VOID } from '../util.js';\nexport var microSeconds = micro;\nimport { ObliviousSet } from 'oblivious-set';\nimport { fillOptionsWithDefaults } from '../options';\nvar DB_PREFIX = 'pubkey.broadcast-channel-0-';\nvar OBJECT_STORE_ID = 'messages';\n/**\n * Use relaxed durability for faster performance on all transactions.\n * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/\n */\n\nexport var TRANSACTION_SETTINGS = {\n  durability: 'relaxed'\n};\nexport var type = 'idb';\nexport function getIdb() {\n  if (typeof indexedDB !== 'undefined') return indexedDB;\n\n  if (typeof window !== 'undefined') {\n    if (typeof window.mozIndexedDB !== 'undefined') return window.mozIndexedDB;\n    if (typeof window.webkitIndexedDB !== 'undefined') return window.webkitIndexedDB;\n    if (typeof window.msIndexedDB !== 'undefined') return window.msIndexedDB;\n  }\n\n  return false;\n}\n/**\n * If possible, we should explicitly commit IndexedDB transactions\n * for better performance.\n * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/\n */\n\nexport function commitIndexedDBTransaction(tx) {\n  if (tx.commit) {\n    tx.commit();\n  }\n}\nexport function createDatabase(channelName) {\n  var IndexedDB = getIdb(); // create table\n\n  var dbName = DB_PREFIX + channelName;\n  /**\n   * All IndexedDB databases are opened without version\n   * because it is a bit faster, especially on firefox\n   * @link http://nparashuram.com/IndexedDB/perf/#Open%20Database%20with%20version\n   */\n\n  var openRequest = IndexedDB.open(dbName);\n\n  openRequest.onupgradeneeded = function (ev) {\n    var db = ev.target.result;\n    db.createObjectStore(OBJECT_STORE_ID, {\n      keyPath: 'id',\n      autoIncrement: true\n    });\n  };\n\n  var dbPromise = new Promise(function (res, rej) {\n    openRequest.onerror = function (ev) {\n      return rej(ev);\n    };\n\n    openRequest.onsuccess = function () {\n      res(openRequest.result);\n    };\n  });\n  return dbPromise;\n}\n/**\n * writes the new message to the database\n * so other readers can find it\n */\n\nexport function writeMessage(db, readerUuid, messageJson) {\n  var time = new Date().getTime();\n  var writeObject = {\n    uuid: readerUuid,\n    time: time,\n    data: messageJson\n  };\n  var tx = db.transaction([OBJECT_STORE_ID], 'readwrite', TRANSACTION_SETTINGS);\n  return new Promise(function (res, rej) {\n    tx.oncomplete = function () {\n      return res();\n    };\n\n    tx.onerror = function (ev) {\n      return rej(ev);\n    };\n\n    var objectStore = tx.objectStore(OBJECT_STORE_ID);\n    objectStore.add(writeObject);\n    commitIndexedDBTransaction(tx);\n  });\n}\nexport function getAllMessages(db) {\n  var tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);\n  var objectStore = tx.objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        ret.push(cursor.value); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n        cursor[\"continue\"]();\n      } else {\n        commitIndexedDBTransaction(tx);\n        res(ret);\n      }\n    };\n  });\n}\nexport function getMessagesHigherThan(db, lastCursorId) {\n  var tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);\n  var objectStore = tx.objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n  /**\n   * Optimization shortcut,\n   * if getAll() can be used, do not use a cursor.\n   * @link https://rxdb.info/slow-indexeddb.html\n   */\n\n  if (objectStore.getAll) {\n    var getAllRequest = objectStore.getAll(keyRangeValue);\n    return new Promise(function (res, rej) {\n      getAllRequest.onerror = function (err) {\n        return rej(err);\n      };\n\n      getAllRequest.onsuccess = function (e) {\n        res(e.target.result);\n      };\n    });\n  }\n\n  function openCursor() {\n    // Occasionally Safari will fail on IDBKeyRange.bound, this\n    // catches that error, having it open the cursor to the first\n    // item. When it gets data it will advance to the desired key.\n    try {\n      keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n      return objectStore.openCursor(keyRangeValue);\n    } catch (e) {\n      return objectStore.openCursor();\n    }\n  }\n\n  return new Promise(function (res, rej) {\n    var openCursorRequest = openCursor();\n\n    openCursorRequest.onerror = function (err) {\n      return rej(err);\n    };\n\n    openCursorRequest.onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        if (cursor.value.id < lastCursorId + 1) {\n          cursor[\"continue\"](lastCursorId + 1);\n        } else {\n          ret.push(cursor.value);\n          cursor[\"continue\"]();\n        }\n      } else {\n        commitIndexedDBTransaction(tx);\n        res(ret);\n      }\n    };\n  });\n}\nexport function removeMessagesById(db, ids) {\n  var tx = db.transaction([OBJECT_STORE_ID], 'readwrite', TRANSACTION_SETTINGS);\n  var objectStore = tx.objectStore(OBJECT_STORE_ID);\n  return Promise.all(ids.map(function (id) {\n    var deleteRequest = objectStore[\"delete\"](id);\n    return new Promise(function (res) {\n      deleteRequest.onsuccess = function () {\n        return res();\n      };\n    });\n  }));\n}\nexport function getOldMessages(db, ttl) {\n  var olderThen = new Date().getTime() - ttl;\n  var tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);\n  var objectStore = tx.objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        var msgObk = cursor.value;\n\n        if (msgObk.time < olderThen) {\n          ret.push(msgObk); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n          cursor[\"continue\"]();\n        } else {\n          // no more old messages,\n          commitIndexedDBTransaction(tx);\n          res(ret);\n          return;\n        }\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nexport function cleanOldMessages(db, ttl) {\n  return getOldMessages(db, ttl).then(function (tooOld) {\n    return removeMessagesById(db, tooOld.map(function (msg) {\n      return msg.id;\n    }));\n  });\n}\nexport function create(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n  return createDatabase(channelName).then(function (db) {\n    var state = {\n      closed: false,\n      lastCursorId: 0,\n      channelName: channelName,\n      options: options,\n      uuid: randomToken(),\n\n      /**\n       * emittedMessagesIds\n       * contains all messages that have been emitted before\n       * @type {ObliviousSet}\n       */\n      eMIs: new ObliviousSet(options.idb.ttl * 2),\n      // ensures we do not read messages in parrallel\n      writeBlockPromise: PROMISE_RESOLVED_VOID,\n      messagesCallback: null,\n      readQueuePromises: [],\n      db: db\n    };\n    /**\n     * Handle abrupt closes that do not originate from db.close().\n     * This could happen, for example, if the underlying storage is\n     * removed or if the user clears the database in the browser's\n     * history preferences.\n     */\n\n    db.onclose = function () {\n      state.closed = true;\n      if (options.idb.onclose) options.idb.onclose();\n    };\n    /**\n     * if service-workers are used,\n     * we have no 'storage'-event if they post a message,\n     * therefore we also have to set an interval\n     */\n\n\n    _readLoop(state);\n\n    return state;\n  });\n}\n\nfunction _readLoop(state) {\n  if (state.closed) return;\n  readNewMessages(state).then(function () {\n    return sleep(state.options.idb.fallbackInterval);\n  }).then(function () {\n    return _readLoop(state);\n  });\n}\n\nfunction _filterMessage(msgObj, state) {\n  if (msgObj.uuid === state.uuid) return false; // send by own\n\n  if (state.eMIs.has(msgObj.id)) return false; // already emitted\n\n  if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback\n\n  return true;\n}\n/**\n * reads all new messages from the database and emits them\n */\n\n\nfunction readNewMessages(state) {\n  // channel already closed\n  if (state.closed) return PROMISE_RESOLVED_VOID; // if no one is listening, we do not need to scan for new messages\n\n  if (!state.messagesCallback) return PROMISE_RESOLVED_VOID;\n  return getMessagesHigherThan(state.db, state.lastCursorId).then(function (newerMessages) {\n    var useMessages = newerMessages\n    /**\n     * there is a bug in iOS where the msgObj can be undefined some times\n     * so we filter them out\n     * @link https://github.com/pubkey/broadcast-channel/issues/19\n     */\n    .filter(function (msgObj) {\n      return !!msgObj;\n    }).map(function (msgObj) {\n      if (msgObj.id > state.lastCursorId) {\n        state.lastCursorId = msgObj.id;\n      }\n\n      return msgObj;\n    }).filter(function (msgObj) {\n      return _filterMessage(msgObj, state);\n    }).sort(function (msgObjA, msgObjB) {\n      return msgObjA.time - msgObjB.time;\n    }); // sort by time\n\n    useMessages.forEach(function (msgObj) {\n      if (state.messagesCallback) {\n        state.eMIs.add(msgObj.id);\n        state.messagesCallback(msgObj.data);\n      }\n    });\n    return PROMISE_RESOLVED_VOID;\n  });\n}\n\nexport function close(channelState) {\n  channelState.closed = true;\n  channelState.db.close();\n}\nexport function postMessage(channelState, messageJson) {\n  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function () {\n    return writeMessage(channelState.db, channelState.uuid, messageJson);\n  }).then(function () {\n    if (randomInt(0, 10) === 0) {\n      /* await (do not await) */\n      cleanOldMessages(channelState.db, channelState.options.idb.ttl);\n    }\n  });\n  return channelState.writeBlockPromise;\n}\nexport function onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n  readNewMessages(channelState);\n}\nexport function canBeUsed() {\n  if (isNode) return false;\n  var idb = getIdb();\n  if (!idb) return false;\n  return true;\n}\nexport function averageResponseTime(options) {\n  return options.idb.fallbackInterval * 2;\n}\nexport default {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};","/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside of webworkers because they have no access to locastorage\n * This is basically implemented to support IE9 or your grandmothers toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */\nimport { ObliviousSet } from 'oblivious-set';\nimport { fillOptionsWithDefaults } from '../options';\nimport { sleep, randomToken, microSeconds as micro, isNode } from '../util';\nexport var microSeconds = micro;\nvar KEY_PREFIX = 'pubkey.broadcastChannel-';\nexport var type = 'localstorage';\n/**\n * copied from crosstab\n * @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32\n */\n\nexport function getLocalStorage() {\n  var localStorage;\n  if (typeof window === 'undefined') return null;\n\n  try {\n    localStorage = window.localStorage;\n    localStorage = window['ie8-eventlistener/storage'] || window.localStorage;\n  } catch (e) {// New versions of Firefox throw a Security exception\n    // if cookies are disabled. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153\n  }\n\n  return localStorage;\n}\nexport function storageKey(channelName) {\n  return KEY_PREFIX + channelName;\n}\n/**\n* writes the new message to the storage\n* and fires the storage-event so other readers can find it\n*/\n\nexport function postMessage(channelState, messageJson) {\n  return new Promise(function (res) {\n    sleep().then(function () {\n      var key = storageKey(channelState.channelName);\n      var writeObj = {\n        token: randomToken(),\n        time: new Date().getTime(),\n        data: messageJson,\n        uuid: channelState.uuid\n      };\n      var value = JSON.stringify(writeObj);\n      getLocalStorage().setItem(key, value);\n      /**\n       * StorageEvent does not fire the 'storage' event\n       * in the window that changes the state of the local storage.\n       * So we fire it manually\n       */\n\n      var ev = document.createEvent('Event');\n      ev.initEvent('storage', true, true);\n      ev.key = key;\n      ev.newValue = value;\n      window.dispatchEvent(ev);\n      res();\n    });\n  });\n}\nexport function addStorageEventListener(channelName, fn) {\n  var key = storageKey(channelName);\n\n  var listener = function listener(ev) {\n    if (ev.key === key) {\n      fn(JSON.parse(ev.newValue));\n    }\n  };\n\n  window.addEventListener('storage', listener);\n  return listener;\n}\nexport function removeStorageEventListener(listener) {\n  window.removeEventListener('storage', listener);\n}\nexport function create(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n\n  if (!canBeUsed()) {\n    throw new Error('BroadcastChannel: localstorage cannot be used');\n  }\n\n  var uuid = randomToken();\n  /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */\n\n  var eMIs = new ObliviousSet(options.localstorage.removeTimeout);\n  var state = {\n    channelName: channelName,\n    uuid: uuid,\n    eMIs: eMIs // emittedMessagesIds\n\n  };\n  state.listener = addStorageEventListener(channelName, function (msgObj) {\n    if (!state.messagesCallback) return; // no listener\n\n    if (msgObj.uuid === uuid) return; // own message\n\n    if (!msgObj.token || eMIs.has(msgObj.token)) return; // already emitted\n\n    if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n\n    eMIs.add(msgObj.token);\n    state.messagesCallback(msgObj.data);\n  });\n  return state;\n}\nexport function close(channelState) {\n  removeStorageEventListener(channelState.listener);\n}\nexport function onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n}\nexport function canBeUsed() {\n  if (isNode) return false;\n  var ls = getLocalStorage();\n  if (!ls) return false;\n\n  try {\n    var key = '__broadcastchannel_check';\n    ls.setItem(key, 'works');\n    ls.removeItem(key);\n  } catch (e) {\n    // Safari 10 in private mode will not allow write access to local\n    // storage and fail with a QuotaExceededError. See\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes\n    return false;\n  }\n\n  return true;\n}\nexport function averageResponseTime() {\n  var defaultTime = 120;\n  var userAgent = navigator.userAgent.toLowerCase();\n\n  if (userAgent.includes('safari') && !userAgent.includes('chrome')) {\n    // safari is much slower so this time is higher\n    return defaultTime * 2;\n  }\n\n  return defaultTime;\n}\nexport default {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};","import { microSeconds as micro } from '../util';\nexport var microSeconds = micro;\nexport var type = 'simulate';\nvar SIMULATE_CHANNELS = new Set();\nexport function create(channelName) {\n  var state = {\n    name: channelName,\n    messagesCallback: null\n  };\n  SIMULATE_CHANNELS.add(state);\n  return state;\n}\nexport function close(channelState) {\n  SIMULATE_CHANNELS[\"delete\"](channelState);\n}\nexport function postMessage(channelState, messageJson) {\n  return new Promise(function (res) {\n    return setTimeout(function () {\n      var channelArray = Array.from(SIMULATE_CHANNELS);\n      channelArray.filter(function (channel) {\n        return channel.name === channelState.name;\n      }).filter(function (channel) {\n        return channel !== channelState;\n      }).filter(function (channel) {\n        return !!channel.messagesCallback;\n      }).forEach(function (channel) {\n        return channel.messagesCallback(messageJson);\n      });\n      res();\n    }, 5);\n  });\n}\nexport function onMessage(channelState, fn) {\n  channelState.messagesCallback = fn;\n}\nexport function canBeUsed() {\n  return true;\n}\nexport function averageResponseTime() {\n  return 5;\n}\nexport default {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};","import NativeMethod from './methods/native.js';\nimport IndexeDbMethod from './methods/indexed-db.js';\nimport LocalstorageMethod from './methods/localstorage.js';\nimport SimulateMethod from './methods/simulate.js'; // the line below will be removed from es5/browser builds\n\n\nimport { isNode } from './util'; // order is important\n\nvar METHODS = [NativeMethod, // fastest\nIndexeDbMethod, LocalstorageMethod];\nexport function chooseMethod(options) {\n  var chooseMethods = [].concat(options.methods, METHODS).filter(Boolean); // the line below will be removed from es5/browser builds\n\n\n\n  if (options.type) {\n    if (options.type === 'simulate') {\n      // only use simulate-method if directly chosen\n      return SimulateMethod;\n    }\n\n    var ret = chooseMethods.find(function (m) {\n      return m.type === options.type;\n    });\n    if (!ret) throw new Error('method-type ' + options.type + ' not found');else return ret;\n  }\n  /**\n   * if no webworker support is needed,\n   * remove idb from the list so that localstorage is been chosen\n   */\n\n\n  if (!options.webWorkerSupport && !isNode) {\n    chooseMethods = chooseMethods.filter(function (m) {\n      return m.type !== 'idb';\n    });\n  }\n\n  var useMethod = chooseMethods.find(function (method) {\n    return method.canBeUsed();\n  });\n  if (!useMethod) throw new Error(\"No useable method found in \" + JSON.stringify(METHODS.map(function (m) {\n    return m.type;\n  })));else return useMethod;\n}","import { isPromise, PROMISE_RESOLVED_FALSE, PROMISE_RESOLVED_VOID } from './util.js';\nimport { chooseMethod } from './method-chooser.js';\nimport { fillOptionsWithDefaults } from './options.js';\n/**\n * Contains all open channels,\n * used in tests to ensure everything is closed.\n */\n\nexport var OPEN_BROADCAST_CHANNELS = new Set();\nvar lastId = 0;\nexport var BroadcastChannel = function BroadcastChannel(name, options) {\n  // identifier of the channel to debug stuff\n  this.id = lastId++;\n  OPEN_BROADCAST_CHANNELS.add(this);\n  this.name = name;\n\n  if (ENFORCED_OPTIONS) {\n    options = ENFORCED_OPTIONS;\n  }\n\n  this.options = fillOptionsWithDefaults(options);\n  this.method = chooseMethod(this.options); // isListening\n\n  this._iL = false;\n  /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */\n\n  this._onML = null;\n  /**\n   * _addEventListeners\n   */\n\n  this._addEL = {\n    message: [],\n    internal: []\n  };\n  /**\n   * Unsend message promises\n   * where the sending is still in progress\n   * @type {Set<Promise>}\n   */\n\n  this._uMP = new Set();\n  /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */\n\n  this._befC = [];\n  /**\n   * _preparePromise\n   */\n\n  this._prepP = null;\n\n  _prepareChannel(this);\n}; // STATICS\n\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */\n\nBroadcastChannel._pubkey = true;\n/**\n * clears the tmp-folder if is node\n * @return {Promise<boolean>} true if has run, false if not node\n */\n\nexport function clearNodeFolder(options) {\n  options = fillOptionsWithDefaults(options);\n  var method = chooseMethod(options);\n\n  if (method.type === 'node') {\n    return method.clearNodeFolder().then(function () {\n      return true;\n    });\n  } else {\n    return PROMISE_RESOLVED_FALSE;\n  }\n}\n/**\n * if set, this method is enforced,\n * no mather what the options are\n */\n\nvar ENFORCED_OPTIONS;\nexport function enforceOptions(options) {\n  ENFORCED_OPTIONS = options;\n} // PROTOTYPE\n\nBroadcastChannel.prototype = {\n  postMessage: function postMessage(msg) {\n    if (this.closed) {\n      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed ' +\n      /**\n       * In the past when this error appeared, it was realy hard to debug.\n       * So now we log the msg together with the error so it at least\n       * gives some clue about where in your application this happens.\n       */\n      JSON.stringify(msg));\n    }\n\n    return _post(this, 'message', msg);\n  },\n  postInternal: function postInternal(msg) {\n    return _post(this, 'internal', msg);\n  },\n\n  set onmessage(fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _removeListenerObject(this, 'message', this._onML);\n\n    if (fn && typeof fn === 'function') {\n      this._onML = listenObj;\n\n      _addListenerObject(this, 'message', listenObj);\n    } else {\n      this._onML = null;\n    }\n  },\n\n  addEventListener: function addEventListener(type, fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _addListenerObject(this, type, listenObj);\n  },\n  removeEventListener: function removeEventListener(type, fn) {\n    var obj = this._addEL[type].find(function (obj) {\n      return obj.fn === fn;\n    });\n\n    _removeListenerObject(this, type, obj);\n  },\n  close: function close() {\n    var _this = this;\n\n    if (this.closed) {\n      return;\n    }\n\n    OPEN_BROADCAST_CHANNELS[\"delete\"](this);\n    this.closed = true;\n    var awaitPrepare = this._prepP ? this._prepP : PROMISE_RESOLVED_VOID;\n    this._onML = null;\n    this._addEL.message = [];\n    return awaitPrepare // wait until all current sending are processed\n    .then(function () {\n      return Promise.all(Array.from(_this._uMP));\n    }) // run before-close hooks\n    .then(function () {\n      return Promise.all(_this._befC.map(function (fn) {\n        return fn();\n      }));\n    }) // close the channel\n    .then(function () {\n      return _this.method.close(_this._state);\n    });\n  },\n\n  get type() {\n    return this.method.type;\n  },\n\n  get isClosed() {\n    return this.closed;\n  }\n\n};\n/**\n * Post a message over the channel\n * @returns {Promise} that resolved when the message sending is done\n */\n\nfunction _post(broadcastChannel, type, msg) {\n  var time = broadcastChannel.method.microSeconds();\n  var msgObj = {\n    time: time,\n    type: type,\n    data: msg\n  };\n  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : PROMISE_RESOLVED_VOID;\n  return awaitPrepare.then(function () {\n    var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj); // add/remove to unsend messages list\n\n    broadcastChannel._uMP.add(sendPromise);\n\n    sendPromise[\"catch\"]().then(function () {\n      return broadcastChannel._uMP[\"delete\"](sendPromise);\n    });\n    return sendPromise;\n  });\n}\n\nfunction _prepareChannel(channel) {\n  var maybePromise = channel.method.create(channel.name, channel.options);\n\n  if (isPromise(maybePromise)) {\n    channel._prepP = maybePromise;\n    maybePromise.then(function (s) {\n      // used in tests to simulate slow runtime\n\n      /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/\n      channel._state = s;\n    });\n  } else {\n    channel._state = maybePromise;\n  }\n}\n\nfunction _hasMessageListeners(channel) {\n  if (channel._addEL.message.length > 0) return true;\n  if (channel._addEL.internal.length > 0) return true;\n  return false;\n}\n\nfunction _addListenerObject(channel, type, obj) {\n  channel._addEL[type].push(obj);\n\n  _startListening(channel);\n}\n\nfunction _removeListenerObject(channel, type, obj) {\n  channel._addEL[type] = channel._addEL[type].filter(function (o) {\n    return o !== obj;\n  });\n\n  _stopListening(channel);\n}\n\nfunction _startListening(channel) {\n  if (!channel._iL && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n    var listenerFn = function listenerFn(msgObj) {\n      channel._addEL[msgObj.type].forEach(function (listenerObject) {\n        /**\n         * Getting the current time in JavaScript has no good precision.\n         * So instead of only listening to events that happend 'after' the listener\n         * was added, we also listen to events that happended 100ms before it.\n         * This ensures that when another process, like a WebWorker, sends events\n         * we do not miss them out because their timestamp is a bit off compared to the main process.\n         * Not doing this would make messages missing when we send data directly after subscribing and awaiting a response.\n         * @link https://johnresig.com/blog/accuracy-of-javascript-time/\n         */\n        var hundredMsInMicro = 100 * 1000;\n        var minMessageTime = listenerObject.time - hundredMsInMicro;\n\n        if (msgObj.time >= minMessageTime) {\n          listenerObject.fn(msgObj.data);\n        }\n      });\n    };\n\n    var time = channel.method.microSeconds();\n\n    if (channel._prepP) {\n      channel._prepP.then(function () {\n        channel._iL = true;\n        channel.method.onMessage(channel._state, listenerFn, time);\n      });\n    } else {\n      channel._iL = true;\n      channel.method.onMessage(channel._state, listenerFn, time);\n    }\n  }\n}\n\nfunction _stopListening(channel) {\n  if (channel._iL && !_hasMessageListeners(channel)) {\n    // noone is listening, stop subscribing\n    channel._iL = false;\n    var time = channel.method.microSeconds();\n    channel.method.onMessage(channel._state, null, time);\n  }\n}","import { IsarCollection } from './collection'\nimport { LinkSchema, Schema } from './schema'\nimport { IsarTxn } from './txn'\nimport { ChangeSet } from './watcher'\nimport { BroadcastChannel } from 'broadcast-channel'\n\nexport class IsarInstance {\n  private static readonly bc = new BroadcastChannel('ISAR_CHANNEL')\n\n  private readonly db: IDBDatabase\n  private readonly relaxedDurability: boolean\n  private collections: Map<string, IsarCollection<any>> = new Map()\n  private eventHandler: EventListener\n\n  constructor(db: IDBDatabase, relaxedDurability: boolean, schemas: Schema[]) {\n    this.db = db\n    this.relaxedDurability = relaxedDurability\n    this.initializeCollections(schemas)\n\n    this.eventHandler = (event: MessageEvent) => {\n      if (\n        event.data &&\n        event.data.type === 'change' &&\n        event.data.instance == this.db.name\n      ) {\n        this.notifyWatchers(event.data.changes, true)\n      }\n    }\n    IsarInstance.bc.addEventListener('message', this.eventHandler)\n  }\n\n  private initializeCollections(schemas: Schema[]) {\n    for (let schema of schemas) {\n      const backlinkStoreNames = schemas.flatMap(s => {\n        if (s.name === schema.name) {\n          return []\n        }\n        return s.links\n          .filter(l => l.target === schema.name)\n          .map(l => {\n            return LinkSchema.getStoreName(s.name, l.target, l.name)\n          })\n      })\n      const col = new IsarCollection(this, schema, backlinkStoreNames)\n      this.collections.set(schema.name, col)\n    }\n  }\n\n  notifyWatchers(\n    changes: Map<string, ChangeSet<any>>,\n    external: boolean = false,\n  ) {\n    let txn: IsarTxn | undefined\n\n    const getTxn = () => {\n      if (txn == null) {\n        txn = this.beginTxn(false)\n      }\n      return txn!\n    }\n    for (let [colName, changeSet] of changes.entries()) {\n      const collection = this.getCollection(colName)\n      collection.notify(changeSet, getTxn)\n    }\n\n    if (!external) {\n      const event: ChangeEvent = {\n        type: 'change',\n        instance: this.db.name,\n        changes,\n      }\n      IsarInstance.bc.postMessage(event)\n    }\n  }\n\n  beginTxn(write: boolean): IsarTxn {\n    const names = this.db.objectStoreNames\n    const mode = write ? 'readwrite' : 'readonly'\n    const options = this.relaxedDurability ? { durability: 'relaxed' } : {}\n    const txn = (this.db as any).transaction(names, mode, options)\n    return new IsarTxn(this, txn, write)\n  }\n\n  getCollection<OBJ>(name: string): IsarCollection<OBJ> {\n    return this.collections.get(name)!\n  }\n\n  close(deleteFromDisk: boolean = false): Promise<void> {\n    IsarInstance.bc.removeEventListener('message', this.eventHandler)\n    this.db.close()\n    if (deleteFromDisk) {\n      const req = indexedDB.deleteDatabase(this.db.name)\n      return new Promise((resolve, reject) => {\n        req.onsuccess = () => {\n          resolve()\n        }\n        req.onerror = () => {\n          reject(req.error)\n        }\n      })\n    } else {\n      return Promise.resolve()\n    }\n  }\n}\n\ntype ChangeEvent = {\n  type: 'change'\n  instance: string\n  changes: Map<string, ChangeSet<any>>\n}\n","import equal from 'fast-deep-equal'\nimport { IsarInstance } from './instance'\nimport { IsarLink } from './link'\nimport { IndexSchema, LinkSchema, Schema } from './schema'\n\nexport function openIsar(\n  name: string,\n  schemas: Schema[],\n  relaxedDurability: boolean,\n): Promise<IsarInstance> {\n  return openInternal(name, schemas, relaxedDurability)\n}\n\nfunction openInternal(\n  name: string,\n  schemas: Schema[],\n  relaxedDurability: boolean,\n  version?: number,\n): Promise<IsarInstance> {\n  return new Promise((resolve, reject) => {\n    const req = indexedDB.open(name, version)\n    req.onsuccess = () => {\n      const db = req.result\n      if (version == null) {\n        const txn = db.transaction(db.objectStoreNames, 'readonly')\n        if (!performUpgrade(txn, true, schemas)) {\n          const newVersion = txn.db.version + 1\n          db.close()\n          resolve(openInternal(name, schemas, relaxedDurability, newVersion))\n          return\n        }\n      }\n\n      const instance = new IsarInstance(db, relaxedDurability, schemas)\n      resolve(instance)\n    }\n    req.onupgradeneeded = () => {\n      performUpgrade(req.transaction!, false, schemas)\n    }\n    req.onerror = () => {\n      reject(req.error)\n    }\n  })\n}\n\nfunction performUpgrade(\n  txn: IDBTransaction,\n  dryRun: boolean,\n  schemas: Schema[],\n): boolean {\n  const schemaStoreNames: string[] = []\n  for (let schema of schemas) {\n    schemaStoreNames.push(schema.name)\n    const schemaIndexNames: string[] = []\n\n    let store: IDBObjectStore\n    if (!txn.objectStoreNames.contains(schema.name)) {\n      if (dryRun) {\n        return false\n      }\n      store = txn.db.createObjectStore(schema.name, {\n        keyPath: schema.idName,\n        autoIncrement: true,\n      })\n    } else {\n      store = txn.objectStore(schema.name)\n    }\n\n    for (let indexSchema of schema.indexes) {\n      schemaIndexNames.push(indexSchema.name)\n      if (store.indexNames.contains(indexSchema.name)) {\n        const index = store.index(indexSchema.name)\n        if (IndexSchema.matchesIndex(schema, indexSchema, index)) {\n          continue\n        } else {\n          if (!dryRun) {\n            store.deleteIndex(indexSchema.name)\n          }\n        }\n      }\n      if (dryRun) {\n        return false\n      }\n      store.createIndex(indexSchema.name, IndexSchema.getKeyPath(indexSchema), {\n        unique: indexSchema.unique,\n        multiEntry: IndexSchema.isIndexMultiEntry(schema, indexSchema),\n      })\n    }\n\n    for (let linkSchema of schema.links) {\n      const name = LinkSchema.getStoreName(\n        schema.name,\n        linkSchema.target,\n        linkSchema.name,\n      )\n      let linkStore: IDBObjectStore\n      if (!txn.objectStoreNames.contains(name)) {\n        if (dryRun) {\n          return false\n        }\n        linkStore = txn.db.createObjectStore(name, {\n          keyPath: ['a', 'b'],\n          autoIncrement: false,\n        })\n      } else {\n        linkStore = txn.objectStore(name)\n      }\n      schemaStoreNames.push(name)\n\n      const indexesOk = equal(\n        [...linkStore.indexNames],\n        [IsarLink.BacklinkIndex],\n      )\n      if (!indexesOk) {\n        if (dryRun) {\n          return false\n        }\n        for (let indexName of linkStore.indexNames) {\n          linkStore.deleteIndex(indexName)\n        }\n        linkStore.createIndex(IsarLink.BacklinkIndex, 'b')\n      }\n    }\n\n    for (let indexName of store.indexNames) {\n      if (schemaIndexNames.indexOf(indexName) === -1) {\n        if (dryRun) {\n          return false\n        }\n        store.deleteIndex(indexName)\n      }\n    }\n  }\n\n  for (let storeName of txn.objectStoreNames) {\n    if (schemaStoreNames.indexOf(storeName) === -1) {\n      if (dryRun) {\n        return false\n      }\n      txn.db.deleteObjectStore(storeName)\n    }\n  }\n\n  return true\n}\n","import { IsarTxn } from './txn'\n\ntype CursorParams = {\n  txn: IsarTxn\n  callback: CursorCallback\n  storeName: string\n  indexName?: string\n  range?: IDBKeyRange\n  offset?: number\n  direction?: IDBCursorDirection\n}\n\ntype CursorCallback = (\n  id: any,\n  value: any,\n  next: Function,\n  resolve: Function,\n  reject: Function,\n) => void\n\nexport function useCursor(params: CursorParams): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const store = params.txn.txn.objectStore(params.storeName)\n    const source =\n      params.indexName != null ? store.index(params.indexName) : store\n    const multiEntry = params.indexName && (source as IDBIndex).multiEntry\n\n    const cursorReq = source.openCursor(params.range, params.direction)\n    cursorReq.onsuccess = () => {\n      const cursor = cursorReq.result\n      if (cursor) {\n        if (params.offset) {\n          cursor.advance(params.offset)\n          params.offset = undefined\n        } else {\n          if (multiEntry) {\n            const isArray = Array.isArray(\n              cursor.value[source.keyPath as string],\n            )\n            if (!isArray) {\n              cursor.continue()\n              return\n            }\n          }\n          params.callback(\n            cursor.primaryKey,\n            cursor.value,\n            function () {\n              cursor.continue()\n            },\n            resolve,\n            reject,\n          )\n        }\n      } else {\n        resolve()\n      }\n    }\n    cursorReq.onerror = e => {\n      reject(e)\n    }\n  })\n}\n","import { IsarCollection } from './collection'\nimport { IsarInstance } from './instance'\nimport { IsarLink } from './link'\nimport { openIsar } from './open'\nimport { IsarQuery } from './query'\nimport { IsarTxn } from './txn'\n\n;(window as any).openIsar = openIsar\n;(window as any).IsarInstance = IsarInstance\n;(window as any).IsarTxn = IsarTxn\n;(window as any).IsarCollection = IsarCollection\n;(window as any).IsarQuery = IsarQuery\n;(window as any).IsarLink = IsarLink\n","import { IsarCollection } from './collection'\nimport { useCursor } from './cursor'\nimport { IsarLink } from './link'\nimport { IsarTxn } from './txn'\n\ntype IdWherClause = {\n  range?: IDBKeyRange\n}\n\ntype IndexWherClause = {\n  indexName: string\n  range?: IDBKeyRange\n}\n\ntype LinkWherClause = {\n  linkCollection: string\n  linkName: string\n  backlink: boolean\n  id: number\n}\n\ntype WherClause = IdWherClause | IndexWherClause | LinkWherClause\n\ntype Filter = (id: number, obj: any) => boolean\n\ntype Cmp = (a: any, b: any) => number\n\ntype DistinctValue = (obj: any) => string\n\nexport class IsarQuery<OBJ> {\n  collection: IsarCollection<OBJ>\n  whereClauses: WherClause[]\n  whereClauseDirection: IDBCursorDirection\n  filter?: Filter\n  sortCmp?: Cmp\n  distinctValue?: DistinctValue\n  offset: number\n  limit: number\n\n  constructor(\n    collection: IsarCollection<OBJ>,\n    whereClauses: WherClause[],\n    whereDistinct: boolean,\n    whereAscending: boolean,\n    filter?: Filter,\n    sortCmp?: Cmp,\n    distinctValue?: DistinctValue,\n    offset?: number,\n    limit?: number,\n  ) {\n    this.collection = collection\n    this.whereClauses = whereClauses\n    this.filter = filter\n    this.sortCmp = sortCmp\n    this.distinctValue = distinctValue\n    this.offset = offset ?? 0\n    this.limit = limit ?? Infinity\n\n    if (whereDistinct) {\n      this.whereClauseDirection = whereAscending ? 'nextunique' : 'prevunique'\n    } else {\n      this.whereClauseDirection = whereAscending ? 'next' : 'prev'\n    }\n\n    if (this.whereClauses.length === 0) {\n      this.whereClauses.push({})\n    }\n  }\n\n  private getWhereClauseRange(\n    whereClause: IdWherClause | IndexWherClause,\n  ): IDBKeyRange {\n    return whereClause.range ?? IDBKeyRange.lowerBound(-Infinity)\n  }\n\n  private async findInternal(txn: IsarTxn, limit: number): Promise<any[]> {\n    const offset = this.offset\n    const unsortedLimit = !this.sortCmp ? offset + limit : Infinity\n    const unsortedDistinct = !this.sortCmp ? this.distinctValue : undefined\n    let results: OBJ[] = []\n    const idsSet = new Set<number>()\n    const distinctSet = new Set<String>()\n\n    const cursorCallback = (\n      id: any,\n      object: any,\n      next: Function,\n      resolve: Function,\n    ) => {\n      if (idsSet.has(id)) {\n        next()\n        return\n      } else {\n        idsSet.add(id)\n      }\n\n      if (this.filter) {\n        if (!this.filter(id, object)) {\n          next()\n          return\n        }\n      }\n      if (unsortedDistinct) {\n        const value = unsortedDistinct(object)\n        if (distinctSet.has(value)) {\n          next()\n          return\n        } else {\n          distinctSet.add(value)\n        }\n      }\n      results.push(object)\n      if (results.length < unsortedLimit) {\n        next()\n      } else {\n        resolve()\n      }\n    }\n\n    for (const whereClause of this.whereClauses) {\n      if (results.length >= unsortedLimit) {\n        break\n      }\n      if ('linkName' in whereClause) {\n        const link = this.collection.isar\n          .getCollection(whereClause.linkCollection)\n          .getLink(whereClause.linkName)!\n        await useCursor({\n          txn,\n          storeName: link.storeName,\n          indexName: whereClause.backlink ? IsarLink.BacklinkIndex : undefined,\n          range: IsarLink.getLinkKeyRange(whereClause.id),\n          direction: this.whereClauseDirection,\n          callback: (key, _, next, resolve, reject) => {\n            const id = (key as number[])[whereClause.backlink ? 0 : 1]\n            this.collection\n              .get(txn, id)\n              .then(obj => {\n                if (obj) {\n                  cursorCallback(id, obj, next, resolve)\n                } else {\n                  next()\n                }\n              })\n              .catch(() => reject())\n          },\n        })\n      } else {\n        const range = this.getWhereClauseRange(whereClause)\n        await useCursor({\n          txn,\n          storeName: this.collection.name,\n          indexName:\n            'indexName' in whereClause ? whereClause.indexName : undefined,\n          range: range,\n          direction: this.whereClauseDirection,\n          callback: cursorCallback,\n        })\n      }\n    }\n\n    if (this.sortCmp) {\n      results.sort(this.sortCmp)\n\n      const distinctValue = this.distinctValue\n      if (distinctValue) {\n        results = results.filter(obj => {\n          const value = distinctValue!(obj)\n          if (!distinctSet.has(value)) {\n            distinctSet.add(value)\n            return true\n          } else {\n            return false\n          }\n        })\n      }\n    }\n\n    return results.slice(offset, offset + limit)\n  }\n\n  findFirst(txn: IsarTxn): Promise<OBJ | undefined> {\n    return this.findInternal(txn, 1).then(results => {\n      return results.length > 0\n        ? this.collection.toObject(results[0])\n        : undefined\n    })\n  }\n\n  findAll(txn: IsarTxn): Promise<OBJ[]> {\n    return this.findInternal(txn, this.limit ?? Infinity).then(results => {\n      return results.map(o => this.collection.toObject(o))\n    })\n  }\n\n  deleteFirst(txn: IsarTxn): Promise<boolean> {\n    return this.findInternal(txn, 1).then(result => {\n      if (result.length !== 0) {\n        return this.collection\n          .delete(txn, this.collection.getId(result[0]))\n          .then(() => true)\n      } else {\n        return false\n      }\n    })\n  }\n\n  deleteAll(txn: IsarTxn): Promise<number> {\n    return this.findInternal(txn, this.limit).then(result => {\n      return this.collection\n        .deleteAll(txn, result.map(this.collection.getId))\n        .then(() => result.length)\n    })\n  }\n\n  min(txn: IsarTxn, key: string): Promise<number | undefined> {\n    return this.findAll(txn).then(results => {\n      let min: number | undefined = undefined\n      for (const obj of results) {\n        const value = (obj as any)[key]\n        if (value != null && (min == null || value < min)) {\n          min = value\n        }\n      }\n      return min\n    })\n  }\n\n  max(txn: IsarTxn, key: string): Promise<number | undefined> {\n    return this.findAll(txn).then(results => {\n      let max: number | undefined = undefined\n      for (const obj of results) {\n        const value = (obj as any)[key]\n        if (value != null && (max == null || value > max)) {\n          max = value\n        }\n      }\n      return max\n    })\n  }\n\n  sum(txn: IsarTxn, key: string): Promise<number> {\n    return this.findAll(txn).then(results => {\n      let sum = 0\n      for (const obj of results) {\n        const value = (obj as any)[key]\n        if (value != null) {\n          sum += value\n        }\n      }\n      return sum\n    })\n  }\n\n  average(txn: IsarTxn, key: string): Promise<number> {\n    return this.findAll(txn).then(results => {\n      let sum = 0\n      let count = 0\n      for (const obj of results) {\n        const value = (obj as any)[key]\n        if (value != null) {\n          sum += value\n          count++\n        }\n      }\n      return sum / count\n    })\n  }\n\n  count(txn: IsarTxn): Promise<number> {\n    return this.findAll(txn).then(result => result.length)\n  }\n\n  private whereClauseMatches(id: number, idbObject: OBJ) {\n    for (const whereClause of this.whereClauses) {\n      if ('linkName' in whereClause) {\n        return true\n      } else if ('indexName' in whereClause) {\n        if (this.collection.isMultiEntryIndex(whereClause.indexName)) {\n          const values = (idbObject as any)[\n            this.collection.getIndexKeyPath(whereClause.indexName!)[0]\n          ]\n          for (let value of values) {\n            if (this.getWhereClauseRange(whereClause).includes(value)) {\n              return true\n            }\n          }\n        } else {\n          let value = this.collection\n            .getIndexKeyPath(whereClause.indexName!)\n            .map(p =>\n              p === this.collection.idName ? id : (idbObject as any)[p],\n            )\n          if (value.length === 1) {\n            value = value[0]\n          }\n          if (this.getWhereClauseRange(whereClause).includes(value)) {\n            return true\n          }\n        }\n      } else if (this.getWhereClauseRange(whereClause).includes(id)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  whereClauseAndFilterMatch(id: number, idbObject: OBJ): boolean {\n    if (!this.whereClauseMatches(id, idbObject)) {\n      return false\n    }\n\n    if (this.filter) {\n      if (!this.filter(id, idbObject)) {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n"],"names":["module","exports","equal","a","b","constructor","length","i","keys","Array","isArray","RegExp","source","flags","valueOf","Object","prototype","toString","hasOwnProperty","call","key","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","definition","o","defineProperty","enumerable","get","obj","prop","bulkDelete","txn","storeName","Promise","resolve","reject","len","lastItem","store","objectStore","req","delete","onerror","abort","error","onsuccess","bulkDeleteByIndex","indexName","index","primaryKeys","indexReq","getAllKeys","isLast","push","result","then","val2Idb","value","obj2Idb","object","idName","create","val","map","IndexSchema","LinkSchema","IsarType","IndexType","isIndexMultiEntry","schema","indexSchema","properties","some","ip","property","find","p","name","type","Value","isList","getKeyPath","matchesIndex","multiEntry","unique","keyPath","getStoreName","sourceName","targetName","linkName","ByteList","BoolList","IntList","FloatList","LongList","DoubleList","StringList","includes","IsarLink","isar","this","getLinkEntry","target","backlink","static","id","IDBKeyRange","bound","Infinity","update","addedTargets","deletedTargets","deletedEmpty","add","clear","keysRes","BacklinkIndex","ids","deleteReq","getLinkKeyRange","IsarChangeSet","cleared","addedObjects","Map","deletedObjectIds","Set","registerChange","idbObject","set","registerCleared","IsarCollection","collectionWatchers","objectWatchers","queryWatchers","watchLazy","callback","watchObject","ow","size","watchQueryInternal","query","lazy","watcher","watchQuery","watchQueryLazy","notify","changes","getTxn","notifyQuery","findAll","callbacks","added","whereClauseAndFilterMatch","backlinkStoreNames","super","indexKeyPaths","boolValues","filter","Bool","uniqueIndexes","indexes","accessors","links","l","multiEntryIndexes","getLink","toObject","indexOf","v","idb2Obj","getId","getIndexKeyPath","isMultiEntryIndex","prepareKey","getInternal","getByIndex","getAllInternal","includeUndefined","results","getAll","getAllByIndex","idbKeys","put","replaceOnConflict","getChangeSet","putAll","objects","changeSet","deleteLinks","linkPromises","backlinkPromises","all","deleteByIndex","getKey","deleteAll","deleteAllByIndex","storeNames","IsarTxn","write","active","collectionName","commit","oncomplete","notifyWatchers","PROMISE_RESOLVED_VOID","sleep","time","resolveWith","res","setTimeout","randomToken","Math","random","substring","lastMs","additional","microSeconds","ms","Date","getTime","isNode","process","channelName","state","messagesCallback","bc","BroadcastChannel","subFns","onmessage","msg","data","close","channelState","onMessage","fn","postMessage","messageJson","err","canBeUsed","window","_pubkey","Error","averageResponseTime","ObliviousSet","ttl","timeMap","has","_this","now","obliviousSet","olderThen","iterator","Symbol","next","removeTooOldValues","originalOptions","arguments","options","JSON","parse","stringify","webWorkerSupport","idb","fallbackInterval","onclose","localstorage","removeTimeout","methods","node","maxParallelWrites","useFastPath","OBJECT_STORE_ID","TRANSACTION_SETTINGS","durability","getIdb","indexedDB","mozIndexedDB","webkitIndexedDB","msIndexedDB","commitIndexedDBTransaction","tx","_readLoop","closed","readNewMessages","db","lastCursorId","transaction","ret","keyRangeValue","getAllRequest","rej","e","openCursorRequest","openCursor","ev","cursor","getMessagesHigherThan","newerMessages","useMessages","msgObj","uuid","eMIs","messagesCallbackTime","_filterMessage","sort","msgObjA","msgObjB","forEach","dbName","openRequest","open","onupgradeneeded","createObjectStore","autoIncrement","createDatabase","writeBlockPromise","readQueuePromises","readerUuid","writeObject","writeMessage","floor","msgObk","getOldMessages","tooOld","deleteRequest","removeMessagesById","getLocalStorage","localStorage","storageKey","ls","setItem","removeItem","listener","newValue","token","addEventListener","addStorageEventListener","removeEventListener","writeObj","document","createEvent","initEvent","dispatchEvent","userAgent","navigator","toLowerCase","defaultTime","SIMULATE_CHANNELS","from","channel","METHODS","OPEN_BROADCAST_CHANNELS","lastId","maybePromise","method","chooseMethods","concat","Boolean","m","useMethod","_iL","_onML","_addEL","message","internal","_uMP","_befC","_prepP","s","_state","_post","broadcastChannel","sendPromise","_hasMessageListeners","_addListenerObject","listenerFn","listenerObject","minMessageTime","_startListening","_removeListenerObject","_stopListening","postInternal","listenObj","awaitPrepare","isClosed","IsarInstance","relaxedDurability","schemas","collections","initializeCollections","eventHandler","event","instance","flatMap","col","external","beginTxn","colName","entries","getCollection","names","objectStoreNames","mode","deleteFromDisk","deleteDatabase","openInternal","version","performUpgrade","newVersion","dryRun","schemaStoreNames","schemaIndexNames","contains","indexNames","deleteIndex","createIndex","linkSchema","linkStore","deleteObjectStore","useCursor","params","cursorReq","range","direction","offset","advance","continue","primaryKey","openIsar","IsarQuery","collection","whereClauses","whereDistinct","whereAscending","sortCmp","distinctValue","limit","whereClauseDirection","getWhereClauseRange","whereClause","lowerBound","async","unsortedLimit","unsortedDistinct","idsSet","distinctSet","cursorCallback","link","linkCollection","_","catch","slice","findFirst","findInternal","deleteFirst","min","max","sum","average","count","whereClauseMatches","values"],"sourceRoot":""}